## [synchronization](#-)

לעתים יש באותה תכנית מספר threads, אשר פועלים על אותו אובייקט. במקרה כזה, בהחלט ייתכן מצב שבו תופסק לרגע פעילותו של thread אחד, ותחל פעולתו של השני (יש לזכור שכל CPU מסוגל לבצע בכל רגע נתון אך ורק thread אחד), וזאת מבלי שהראשון יסיים סדרה של פעולות, אשר אי השלמתה עלול לגרום לטעויות בהמשך.</br>

 
דוגמא אחת למצב כזה היא שני threads אשר פועלים על אובייקט שמתאר מחסנית של נתונים. אם thread אחד ביצע הוספה של פריט אל המחסנית ולא הספיק לעדכן את מספר האינדקס במחסנית כיוון ש-thread שני הפסיק את פעולתו והתחיל לבצע פעולה של הסרת פריט מהמחסנית – במקרה כזה הפריט שכביכול הוסף 'כאילו' לא הוסף.</br>
[המילה השמורה **synchronized** באה לפתור בעיה זו](#-).</br>
 
 
בכל אובייקט קיים משתנה דגל בשם **“lock flag"**. המילה השמורה **synchronized**  מאפשרת שליטה מסוימת במשתנה זה. משתנה זה – כשהוא מודלק במסגרת פעולתו של thread נתון (וכל עוד אותו thread נתון לא כיבה אותו), הגישה אליו מתוך threads אחרים (אשר גם מנסים לגשת אליו תחת השפעתה של המילה השמורה synchronized) לא מתאפשרת. ניתן לדמיין את אופן השימוש במשתנה lock flag למעין מפתח שיש בכל אובייקט וש-thread לוקח לידיו כאשר עליו לבצע בלוק **synchronized** (יוסבר בהמשך).</br>

 
קיימות שתי דרכים טכניות להשתמש במילה השמורה synchronized: </br>
	1.  אפשרות אחת כוללת כתיבה של בלוק פקודות שכותרתו **synchronized** ושבשורת הכותרת שלו מופיע בסוגריים עגולות, לאחר המילה synchronized,
	 ה-reference של האובייקט שאליו הבלוק מתייחס.</br>
 
 
ברגע ש-thread נתון מגיע בפעולתו לבלוק synchronized כדי שהוא יוכל להמשיך ולבצע את הפקודות שמופיעות בתוכו עליו לקבל לידיו את ה-lock flag של האובייקט שאליו הבלוק מתייחס. אם ה-lock flag הנדרש זמין אז ה-thread לוקח אותו לידיו ומבצע את בלוק הפקודות. בסוף ביצוע בלוק הפקודות ה-thread משחרר את ה-lock flag. אם ה-lock flag איננו זמין אז ה-thread ממתין עד שהוא נהיה זמין.</br>
 
להלן דוגמא למחלקה שמתארת מחסנית.</br> 
באופן שבו המחלקה Stack מוגדרת, אם פעולת ה-push תיפסק לפני הקידום של המשתנה top עקב הפסקת ה-thread הפעיל לטובת פעולתו של thread אחר שלמות הנתונים שמוחזקים על ידי האובייקט Stack תיפגע.</br>
כדי לפתור בעייתיות זו באמצעות המילה השמורה synchronized יש להוסיף אותה עפ"י ההסבר שהוצג באופן הבא:</br>


```java
public class StackBlockSynchronized {
 
	private int top = 0;
	private int data[] = new int[10];
 
	public void push(int num) {
		synchronized (this) {
			data[top] = num;
			top++;
		}
	}
 
	public int pop() {
		synchronized (this) {
			return data[--top];
		}
	}
}
```
 
בהוספת המילה השמורה באופן האמור, כאשר thread ינסה להפעיל את הפקודות שבתוך הבלוק הוא יוכל לעשות זאת אך ורק אם ה-lock flag של האובייקט (במקרה זה של האובייקט שמייצג את המחסנית) יהיה זמין. במידה שהוא זמין אז ה-thread יקח אותו לידיו ויתחיל לבצע את הפקודות בבלוק. עם סיום הבלוק ה-thread יחזיר את ה-lock flag למקומו. כדי להבטיח את שלמות הנתונים של המחסנית יש לוודא שכל מתודה אשר ניגש למשתנים הרגישים תעשה זאת מתוך בלוק synchronized מתאים. כמו כן, כדי להבטיח שגישה ישירה למשתנים לא תתאפשר יש להגדירם עם הרשאת הגישה private. כאשר thread מסויים ייקח לידיו את ה-lock flag של האובייקט אף thread אחר לא יוכל לבצע פעולות אחרות על האובייקט האמור מתוך בלוק synchronized אשר כדי לבצען יש צורך באותוlock flag. (א..) </br>
 
ה-“lock flag" של אובייקט מסוים אשר מוחזק על ידי thread משוחרר מאחיזה זו כאשר מסתיימת פעולתו של הבלוק שסומן על ידי המילה השמורה synchronized.  אם הבלוק הסתיים בגלל פעולת break או בגלל שנזרק exception – גם אז ה- “lock flag" ישוחרר. </br>
 
	2. דרך שניה לשימוש במילה השמורה synchronized היא למקם אותה בכותרת של המתודה. כאשר נתונה מתודה שכל פעולותיה מתוחמות בתוך בלוק synchronized ניתן לוותר על בלוק ה-synchronized ולהוסיף במקומו את המילה synchronized אל הכותרת של המתודה. המשמעות זהה בשני המקרים.

```java
public class StackMethodSynchronized {
 
	private int top = 0;
	private int data[] = new int[10];
 
	public synchronized void push(int num) {
		data[top] = num;
		top++;
	}
 
	public int pop() {
		synchronized (this) {
			return data[--top];
		}
	}
}
```
 
קוד של מתודה עם synchronized block :
```java
public void push(int num) {
	synchronized (this) {
		data[top] = num;
		top++;
	}
}
```
הקוד הבא של מתודה מסנכרנת זהה לקוד של "מתטדה עם בלוק סינכרון" :
  
```java
public synchronized void push(int num) {
	data[top] = num;
	top++;
}
```
 
יש לשים לב לעובדה, ששימוש במילה השמורה synchronized בכותרת של המתודה גורם לכך שכל הקוד שכתוב בתוכה ייחשב לקוד אשר מתוחם ב-synchtonized block באופן שכל עוד שהריצה של המתודה לא הסתיימה, ה-“lock flag”  לא ישוחרר. זאת עלול לגרום לכך שה-“lock flag" יוחזק יותר מהדרוש.  מצד שני, הוספת המילה synchronized לכותרתה של מתודה מספקת אינפורמציה למתכנתים שעומדים להשתמש בה (היא מודיעה להם שהשימוש במתודה גורם להחזקתו של ה-“lock flag” על כל המשתמע מכך). יתר על כן, ה-javadoc יכול לספק בתיעוד שהוא  יוצר חיווי מתאים להיותה של מתודה synchronized. ה-javadoc לא פועל באופן זהה כאשר מדובר ב-synchronized block שטמון בין שורות הקוד של התכנית.</br>

 
לסיכום, כדי שתישמר שלמותו של אובייקט אשר נגיש ל-threads שונים, יש לוודא כי כל גישה אליו נעשית מתוך  synchronized block או מתוך synchronized method. כמו כן, אותו מידע חייב להיות מוחזק במשתנים עם הרשאת הגישה private. אם המידע יוחזק במשתנים שהגישה אליהם אפשרית ממחלקות אחרות אז כלל לא בטוח שהשימוש ב-synchronized אכן ישיג את מטרתו. הגישה ממחלקות אחרות אל אותם משתנים תתאפשר באופן ישיר, ובכך לא תובטח שלימותם של הנתונים.  


![Sync_Method_to_Sync_Block](https://user-images.githubusercontent.com/36256986/155880298-85503c32-e699-4988-896f-5eca2addd9bf.PNG)

